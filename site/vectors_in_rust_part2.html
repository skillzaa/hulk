
    <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hulk</title>    
<link rel="stylesheet" href="./main.css">
</head>
<body>
    
    <header id="header">
	<nav class="links" style="--items: 1;">
		<a href="./index.html">Home</a>
		<span class="line"></span>
	</nav>
</header>
    <h1>Vectors in Rust part-2</h1>
<p>Lets look at the following code. This will not compile.</p>
<pre><code class="language-rust">fn main() {
   let mut v:Vec&lt;i32&gt; = vec![1,2,3,4,5];
   //==== Immutable borrow 
   let first = &amp;v[0];
   //==== Mutable borrow
   v.push(6);
   println!(&quot;first{}&quot;,first);
}
</code></pre>
<blockquote>
<p>We can not have a mutable borrow and a non mutable borrow in the same scope.Adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isnâ€™t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</p>
</blockquote>
<hr />
<h2>Iterating over the Values in a Vector</h2>
<p>We can do it like:</p>
<pre><code class="language-rust"> let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
</code></pre>
<p>OR</p>
<pre><code class="language-rust"> let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
  }
</code></pre>
<h2>Using an Enum to Store Multiple Types</h2>
<pre><code class="language-rust">  enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
</code></pre>

    </body>
</html>
    